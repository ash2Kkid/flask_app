name: CI/CD Pipeline for Simple Flask App with Agent Zero

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  build-and-test:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: Install Agent Zero and dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y python3-pip python3-venv git
          git clone https://github.com/frdel/agent-zero.git
          cd agent-zero
          python3 -m venv venv
          source venv/bin/activate
          pip install --upgrade pip setuptools
          pip install -r requirements.txt langchain_openai yt-dlp
          # Create config.py
          cat > config.py << 'EOF'
          import os
          from dotenv import load_dotenv
          load_dotenv()

          class Config:
              code_exec_ssh_enabled = os.getenv("CODE_EXEC_SSH_ENABLED", "false").lower() == "true"
              code_exec_ssh_addr = os.getenv("CODE_EXEC_SSH_ADDR", "localhost")
              code_exec_ssh_port = int(os.getenv("CODE_EXEC_SSH_PORT", 55022))
              code_exec_ssh_user = os.getenv("CODE_EXEC_SSH_USER", "root")
              code_exec_ssh_pass = os.getenv("CODE_EXEC_SSH_PASS", "")
              code_exec_docker_enabled = os.getenv("CODE_EXEC_DOCKER_ENABLED", "false").lower() == "true"
              code_exec_docker_name = os.getenv("CODE_EXEC_DOCKER_NAME", "agent-zero")
              code_exec_docker_image = os.getenv("CODE_EXEC_DOCKER_IMAGE", "python:3.9")
              code_exec_docker_ports = os.getenv("CODE_EXEC_DOCKER_PORTS", "")
              code_exec_docker_volumes = os.getenv("CODE_EXEC_DOCKER_VOLUMES", "")
          EOF
          # Update file_info.py to bypass MCP_PORT
          cat > python/api/file_info.py << 'EOF'
          from python.api.base_api import BaseApi
          import os

          class FileInfoApi(BaseApi):
              async def process(self, input_data, request):
                  path = input_data.get("path")
                  if not path:
                      return {"error": "Path is required"}
                  try:
                      if os.path.exists(path):
                          stats = os.stat(path)
                          return {
                              "path": path,
                              "exists": True,
                              "size": stats.st_size,
                              "mtime": stats.st_mtime,
                              "is_file": os.path.isfile(path),
                              "is_dir": os.path.isdir(path)
                          }
                      else:
                          return {"path": path, "exists": False}
                  except Exception as e:
                      return {"error": str(e)}
          EOF
          # Update code_execution_tool.py with logging
          cat > python/tools/code_execution_tool.py << 'EOF'
          import asyncio
          from dataclasses import dataclass
          import os
          import shlex
          import time
          from python.helpers import async_subprocess
          from python.helpers.tool import Tool, Response
          from python.helpers import files, rfc_exchange
          from python.helpers.print_style import PrintStyle
          from python.helpers.shell_local import LocalInteractiveSession
          from python.helpers.shell_ssh import SSHInteractiveSession
          from python.helpers.docker import DockerContainerManager
          from python.helpers.messages import truncate_text
          import re

          @dataclass
          class State:
              shells: dict[int, LocalInteractiveSession | SSHInteractiveSession]
              docker: DockerContainerManager | None

          class CodeExecution(Tool):
              def __init__(self, **kwargs):
                  super().__init__(**kwargs)
                  self.ssh_key = kwargs.get('ssh_key', '~/.ssh/id_rsa')
                  self.root_password = None
                  self.state_prepared = False
                  self.state = None

              async def execute(self, **kwargs):
                  await self.agent.handle_intervention()
                  await self.prepare_state()
                  runtime = self.args.get("runtime", "").lower().strip()
                  session = int(self.args.get("session", 0))
                  if runtime == "python":
                      response = await self.execute_python_code(
                          code=self.args["code"], session=session
                      )
                  elif runtime == "nodejs":
                      response = await self.execute_nodejs_code(
                          code=self.args["code"], session=session
                      )
                  elif runtime == "terminal":
                      response = await self.execute_terminal_command(
                          command=self.args["code"], session=session
                      )
                  elif runtime == "output":
                      response = await self.get_terminal_output(
                          session=session, first_output_timeout=60, between_output_timeout=5
                      )
                  elif runtime == "reset":
                      response = await self.reset_terminal(session=session)
                  else:
                      response = self.agent.read_prompt(
                          "fw.code.runtime_wrong.md", runtime=runtime
                      )
                  if not response:
                      response = self.agent.read_prompt(
                          "fw.code.info.md", info=self.agent.read_prompt("fw.code.no_output.md")
                      )
                  return Response(message=response, break_loop=False)

              def get_log_object(self):
                  return self.agent.context.log.log(
                      type="code_exe",
                      heading=f"{self.agent.agent_name}: Using tool '{self.name}'",
                      content="",
                      kvps=self.args,
                  )

              async def after_execution(self, response, **kwargs):
                  self.agent.hist_add_tool_result(self.name, response.message)

              async def prepare_state(self, reset=False, session=None):
                  if not self.state_prepared:
                      self.state_prepared = True
                      if os.path.exists(self.ssh_key):
                          await async_subprocess(f"chmod 600 {self.ssh_key}")
                      self.root_password = os.getenv("RFC_PASSWORD", "rfc123")
                      self.state = self.agent.get_data("_cet_state")
                      if not self.state or reset:
                          docker = None
                          shells = {} if not self.state else self.state.shells.copy()
                          if session is not None and session in shells:
                              shells[session].close()
                              del shells[session]
                          elif reset and not session:
                              for s in list(shells.keys()):
                                  shells[s].close()
                              shells = {}
                          if 0 not in shells:
                              shell = LocalInteractiveSession()
                              shells[0] = shell
                              await shell.connect()
                          self.state = State(shells=shells, docker=docker)
                      self.agent.set_data("_cet_state", self.state)

              async def execute_python_code(self, session: int, code: str, reset: bool = False):
                  escaped_code = shlex.quote(code)
                  command = f"ipython -c {escaped_code}"
                  return await self.terminal_session(session, command, reset)

              async def execute_nodejs_code(self, session: int, code: str, reset: bool = False):
                  escaped_code = shlex.quote(code)
                  command = f"node /exe/node_eval.js {escaped_code}"
                  return await self.terminal_session(session, command, reset)

              async def execute_terminal_command(self, session: int, command: str, reset: bool = False):
                  return await self.terminal_session(session, command, reset)

              async def terminal_session(self, session: int, command: str, reset: bool = False):
                  await self.agent.handle_intervention()
                  PrintStyle(font_color="#FFA500").print(f"Executing command: {command}")
                  for i in range(2):
                      try:
                          if reset:
                              await self.reset_terminal()
                          if session not in self.state.shells:
                              shell = LocalInteractiveSession()
                              self.state.shells[session] = shell
                              await shell.connect()
                          self.state.shells[session].send_command(command)
                          PrintStyle(
                              background_color="white", font_color="#1B4F72", bold=True
                          ).print(f"{self.agent.agent_name} code execution output")
                          return await self.get_terminal_output(session)
                      except Exception as e:
                          PrintStyle.error(f"Attempt {i+1} failed: {str(e)}")
                          if i == 1:
                              await self.prepare_state(reset=True)
                              continue
                          else:
                              raise e

              async def get_terminal_output(
                  self,
                  session=0,
                  reset_full_output=True,
                  first_output_timeout=30,
                  between_output_timeout=15,
                  max_exec_timeout=180,
                  sleep_time=0.1,
              ):
                  prompt_patterns = [
                      re.compile(r"\\(venv\\).+[$#] ?$"),
                      re.compile(r"root@[^:]+:[^#]+# ?$"),
                      re.compile(r"[a-zA-Z0-9_.-]+@[^:]+:[^$#]+[$#] ?$"),
                  ]
                  start_time = time.time()
                  last_output_time = start_time
                  full_output = ""
                  truncated_output = ""
                  got_output = False
                  while True:
                      await asyncio.sleep(sleep_time)
                      full_output, partial_output = await self.state.shells[session].read_output(
                          timeout=3, reset_full_output=reset_full_output
                      )
                      reset_full_output = False
                      await self.agent.handle_intervention()
                      now = time.time()
                      if partial_output:
                          PrintStyle(font_color="#85C1E9").stream(partial_output)
                          truncated_output = truncate_text(
                              agent=self.agent, output=full_output, threshold=10000
                          )
                          self.log.update(content=truncated_output)
                          last_output_time = now
                          got_output = True
                          last_lines = truncated_output.splitlines()[-3:] if truncated_output else []
                          for line in last_lines:
                              for pat in prompt_patterns:
                                  if pat.search(line.strip()):
                                      PrintStyle.info(
                                          "Detected shell prompt, returning output early."
                                      )
                                      return truncated_output
                      if now - start_time > max_exec_timeout:
                          sysinfo = self.agent.read_prompt(
                              "fw.code.max_time.md", timeout=max_exec_timeout
                          )
                          response = self.agent.read_prompt("fw.code.info.md", info=sysinfo)
                          if truncated_output:
                              response = truncated_output + "\n\n" + response
                          PrintStyle.warning(sysinfo)
                          self.log.update(content=response)
                          return response
                      if not got_output:
                          if now - start_time > first_output_timeout:
                              sysinfo = self.agent.read_prompt(
                                  "fw.code.no_out_time.md", timeout=first_output_timeout
                              )
                              response = self.agent.read_prompt("fw.code.info.md", info=sysinfo)
                              PrintStyle.warning(sysinfo)
                              self.log.update(content=response)
                              return response
                      else:
                          if now - last_output_time > between_output_timeout:
                              sysinfo = self.agent.read_prompt(
                                  "fw.code.pause_time.md", timeout=between_output_timeout
                              )
                              response = self.agent.read_prompt("fw.code.info.md", info=sysinfo)
                              if truncated_output:
                                  response = truncated_output + "\n\n" + response
                              PrintStyle.warning(sysinfo)
                              self.log.update(content=response)
                              return response

              async def reset_terminal(self, session=0, reason: str | None = None):
                  if reason:
                      PrintStyle(font_color="#FFA500", bold=True).print(
                          f"Resetting terminal session {session}... Reason: {reason}"
                      )
                  else:
                      PrintStyle(font_color="#FFA500", bold=True).print(
                          f"Resetting terminal session {session}..."
                      )
                  await self.prepare_state(reset=True, session=session)
                  response = self.agent.read_prompt(
                      "fw.code.info.md", info=self.agent.read_prompt("fw.code.reset.md")
                  )
                  self.log.update(content=response)
                  return response
          EOF
          # Create async_subprocess.py
          cat > python/helpers/async_subprocess.py << 'EOF'
          import asyncio
          import subprocess

          async def async_subprocess(command: str, check: bool = True) -> tuple[str, str, int]:
              process = await asyncio.create_subprocess_shell(
                  command,
                  stdout=asyncio.subprocess.PIPE,
                  stderr=asyncio.subprocess.PIPE
              )
              stdout, stderr = await process.communicate()
              return stdout.decode(), stderr.decode(), process.returncode
          EOF
          # Create .env
          echo "API_KEY_OPENROUTER=${{ secrets.OPENROUTER_API_KEY }}" > .env
          echo "OPENROUTER_API_BASE=https://openrouter.ai/api/v1" >> .env
          echo "OPENROUTER_HTTP_REFERER=http://localhost:8080" >> .env
          echo "OPENROUTER_X_TITLE=Agent Zero" >> .env
          echo "chat_model_provider=OPENAI" >> .env
          echo "chat_model_name=deepseek/deepseek-r1:free" >> .env
          echo "chat_model_kwargs={\"base_url\": \"https://openrouter.ai/api/v1\", \"http_referer\": \"http://localhost:8080\", \"x_title\": \"Agent Zero\"}" >> .env
          echo "AGENT_ZERO_API_URL=http://localhost:50001/message" >> .env
          echo "AGENT_ZERO_AUTH=admin:admin123" >> .env
          echo "RFC_PASSWORD=rfc123" >> .env
          echo "MCP_PORT=55080" >> .env
          echo "CODE_EXEC_SSH_ENABLED=false" >> .env
          mv python/extensions/message_loop_prompts_after/_50_recall_memories.py python/extensions/message_loop_prompts_after/_50_recall_memories.py.bak
          mv python/extensions/message_loop_prompts_after/_91_recall_wait.py python/extensions/message_loop_prompts_after/_91_recall_wait.py.bak
          # Clear Agent Zero state
          rm -rf *.log *.json
        env:
          API_KEY_OPENROUTER: ${{ secrets.OPENROUTER_API_KEY }}

      - name: Install app dependencies
        run: |
          cd $GITHUB_WORKSPACE
          python3 -m venv venv
          source venv/bin/activate
          echo -e "flask==2.3.3\nrequests==2.32.3\npython-dotenv==1.0.1\npytest==8.3.2" > requirements.txt
          pip install -r requirements.txt
        continue-on-error: true

      - name: Create app.py
        run: |
          cd $GITHUB_WORKSPACE
          cat > app.py << 'EOF'
          from flask import Flask, request, jsonify
          import requests
          import base64
          import os
          from dotenv import load_dotenv
          load_dotenv()

          app = Flask(__name__)

          @app.route('/run-task', methods=['POST'])
          def run_task():
              try:
                  task_data = request.json
                  if not task_data or 'task' not in task_data:
                      return jsonify({"error": "Task is required"}), 400
                  agent_zero_url = os.getenv("AGENT_ZERO_API_URL", "http://localhost:50001/message")
                  auth = os.getenv("AGENT_ZERO_AUTH", "admin:admin123")
                  auth_header = f"Basic {base64.b64encode(auth.encode()).decode()}"
                  response = requests.post(
                      agent_zero_url,
                      json=task_data,
                      headers={"Content-Type": "application/json", "Authorization": auth_header},
                      timeout=30
                  )
                  return jsonify(response.json()), response.status_code
              except requests.exceptions.Timeout:
                  return jsonify({"error": "Agent Zero API timed out"}), 504
              except Exception as e:
                  return jsonify({"error": str(e)}), 500

          @app.route('/agent/deploy-decision', methods=['POST'])
          def deploy_decision():
              try:
                  return jsonify({"deploy": True, "strategy": "canary"}), 200
              except Exception as e:
                  return jsonify({"error": str(e)}), 500

          @app.route('/deploy', methods=['POST'])
          def deploy():
              try:
                  staging_dir = os.getenv("STAGING_DIRECTORY", "$GITHUB_WORKSPACE/staging-app")
                  os.makedirs(staging_dir, exist_ok=True)
                  with open(os.path.join(staging_dir, "deployed.txt"), "w") as f:
                      f.write("Deployed")
                  return jsonify({"status": f"Deployment successful to {staging_dir}"}), 200
              except Exception as e:
                  return jsonify({"error": str(e)}), 500

          if __name__ == "__main__":
              port = int(os.getenv("FLASK_PORT", 8080))
              app.run(port=port, debug=True)
          EOF

      - name: Start Agent Zero
        run: |
          cd $GITHUB_WORKSPACE/agent-zero
          source venv/bin/activate
          python run_ui.py &
          sleep 10
          netstat -an | grep 50001 || echo "Agent Zero not running on port 50001"
        continue-on-error: true

      - name: Start Flask App
        run: |
          cd $GITHUB_WORKSPACE
          source venv/bin/activate
          python app.py &
          sleep 5
          netstat -an | grep 8080 || echo "Flask app not running on port 8080"
        continue-on-error: true

      - name: Run tests
        run: |
          cd $GITHUB_WORKSPACE
          source venv/bin/activate
          curl -v -m 30 -H "Content-Type: application/json" -H "Authorization: Basic YWRtaW46YWRtaW4xMjM=" -d '{"task": "Verify yt-dlp installation"}' http://localhost:50001/message
          curl -v -m 30 -H "Content-Type: application/json" -H "Authorization: Basic YWRtaW46YWRtaW4xMjM=" -d '{"task": "Verify yt-dlp installation"}' http://localhost:8080/run-task
          curl -v -m 30 -H "Content-Type: application/json" -H "Authorization: Basic YWRtaW46YWRtaW4xMjM=" -d '{"test_status": "passed"}' http://localhost:8080/agent/deploy-decision
          curl -v -m 30 -H "Content-Type: application/json" -d '{}' http://localhost:8080/deploy
          python -m pytest tests/ --verbose || echo "Tests failed, continuing"
        continue-on-error: true

      - name: Agent Zero - Analyze test failures
        if: failure()
        run: |
          cd $GITHUB_WORKSPACE/agent-zero
          source venv/bin/activate
          python run_ui.py --task "Analyze pytest output for errors and suggest fixes"
        env:
          API_KEY_OPENROUTER: ${{ secrets.OPENROUTER_API_KEY }}
        continue-on-error: true

      - name: Build the app
        run: |
          cd $GITHUB_WORKSPACE
          source venv/bin/activate
          if [ -f setup.py ]; then python setup.py build; else echo "No setup.py, skipping build"; fi
        continue-on-error: true

      - name: Agent Zero - Analyze build failures
        if: failure()
        run: |
          cd $GITHUB_WORKSPACE/agent-zero
          source venv/bin/activate
          python run_ui.py --task "Analyze build log for errors and suggest fixes"
        env:
          API_KEY_OPENROUTER: ${{ secrets.OPENROUTER_API_KEY }}
        continue-on-error: true

      - name: Deploy to staging
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        run: |
          cd $GITHUB_WORKSPACE
          source venv/bin/activate
          mkdir -p staging-app
          echo "Deployed" > staging-app/deployed.txt
          echo "Deployment successful to $GITHUB_WORKSPACE/staging-app"
        env:
          STAGING_DIRECTORY: $GITHUB_WORKSPACE/staging-app

      - name: Agent Zero - Monitor deployment
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        run: |
          cd $GITHUB_WORKSPACE/agent-zero
          source venv/bin/activate
          python run_ui.py --task "Monitor staging deployment and suggest rollback if errors detected"
        env:
          API_KEY_OPENROUTER: ${{ secrets.OPENROUTER_API_KEY }}
        continue-on-error: true

      - name: Debug Agent Zero structure
        run: |
          ls -la $GITHUB_WORKSPACE/agent-zero/
          cat $GITHUB_WORKSPACE/agent-zero/setup.py || echo "No setup.py"
          cat $GITHUB_WORKSPACE/agent-zero/pyproject.toml || echo "No pyproject.toml"
          ls -la $GITHUB_WORKSPACE/staging-app/
          cat $GITHUB_WORKSPACE/staging-app/deployed.txt || echo "No deployed.txt"
          yt-dlp --version || echo "yt-dlp not installed"
          netstat -an | grep 55080 || echo "No service on port 55080"